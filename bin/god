#!/usr/bin/env ruby

$:.unshift File.join(File.dirname(__FILE__), *%w[.. lib])

require 'rubygems'
require 'optparse'
require 'drb'

require 'daemons'
require 'god'


options = {:daemonize => true, :port => 17165}

OptionParser.new do |opts|
  opts.banner = <<-EOF
Usage: god [command] [options]

  Commands:
    start <watch or group name>
    stop <watch or group name>
    monitor <watch or group name>
    unmonitor <watch or group name>

  Options:
EOF

  opts.on("-cCONFIG", "--config-file CONFIG", "Configuration file") do |x|
    options[:config] = x
  end
  
  opts.on("-pPORT", "--port PORT", "Communications port") do |x|
    options[:port] = x
  end
  
  opts.on("-D", "--no-daemonize", "Don't daemonize") do
    options[:daemonize] = false
  end
  
  opts.on("-v", "--version", "Print the version number and exit") do
    options[:version] = true
  end
end.parse!

if options[:version]
  puts "Version #{God::VERSION}"
  exit
elsif command = ARGV[0]
  # a command was specified
  
  # get the name of the watch/group
  name = ARGV[1]
  
  # connect to remote drb
  DRb.start_service
  server = DRbObject.new nil, "druby://localhost:#{options[:port]}"
  
  # get the list of watches
  watches = Array(server.meddle.watches[name] || server.meddle.groups[name])
  
  # do the command
  case command
    when "start", "monitor"
      watches.each { |w| w.monitor }
    when "restart"
      watches.each { |w| w.move(:restart) }
    when "stop"
      watches.each { |w| w.unmonitor.action(:stop) }
    when "unmonitor"
      watches.each { |w| w.unmonitor }
    else
      abort "Command '#{command}' is not valid. Run 'god --help' for usage"
  end
else
  # start god
  
  options[:config] = File.expand_path(options[:config]) if options[:config]

  Daemons.daemonize if options[:daemonize]

  load options[:config]
end
